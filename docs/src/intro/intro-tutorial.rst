.. _intro-tutorial:

Introduction to Solverz
=======================

Solverz helps you to **solve equations numerically** in a versatile way.

Let's take an example. Say we wanted to solve the equation

    .. math::
        e^x+x-3=0,

which admits no analytical solution. As a result, we have to use numerical approaches, such as the Newton method,
to approximate the solution with iterations.

Assume that $g(x)=e^x+x-3$ and given initial value $x_0$ of variable $x$, the solving process by Newton method can be written as

    .. math::
        x_{k+1} = x_k - \frac{g(x_k)}{g'(x_k)}\quad k=0,1,2,\cdots

where $g'(x)$ denotes the derivative of $g$ w.r.t. $x$.

We, or more likely a computer, keeps increasing $k$ and deriving $x_k$ until for some $k$, $g(x_k)$ is within the prescribed tolerance, such as 1e-10.

Though the above solution does not seem to be burdensome, it may take you several minutes to code and debug the numerical computation programmes.
Here, with the aid of Solverz, you can solve the equation as easily as follows

1. Declare your equations using strings

   >>> from Solverz.eqn import Eqn
   >>> from Solverz.equations import AE
   >>> E = Eqn(name='E', e_str='exp(x)+x-3')
   >>> g = AE(name='g', eqn=E)

2. Declare the unknown variables and give the initial values.

   >>> from Solverz.var import Var
   >>> from Solverz.variables import Vars
   >>> x = Var(name='x')
   >>> x.v = [0]
   >>> x = Vars([x])

3. Solve the equation with Solverz' built-in Newton Solver

   >>> from Solverz.solver import nr_method
   >>> x = nr_method(g, x)
   >>> x['x']
   array([0.79205997])

To explain how this happened, let's get an insight into the Newton method function, which is

    .. literalinclude:: ../../../Solverz/solvers/aesolver.py
        :language: python
        :pyobject: nr_method

Two numerical interfaces, `eqn.g()` (for $g(x)$) and `eqn.j()` (for $g'(x)$, i.e. the Jacobian matrix), are automatically generated by Solverz.
Therefore, we need only a few lines of codes to construct the Newton method and the codes are nearly the same as how we derive the newton method mathematically.

Let's see another example, a differential algebraic equation

    .. math::
        \begin{cases}
          x' = -x^3+0.5y^2 &  \\
          0  = x^2 + y^2 - 2& \\
          x(0)=1,\quad y(0)=1
        \end{cases}

which cannot be solved analytically either. Alternatively, we can solve the equation at a series of discrete time nodes, say
$t_0$, $t_1$, $\cdots$ using the so-called numerical integration methods (see [Haierer1996]_).

Here, we use the classic trapezoidal method. Assume $f(x,y)=-x^3+0.5y^2$ and $g(x,y)=x^2 + y^2 - 2$, the equations derived by trapezoidal method
can be written as

    .. math::
        \begin{cases}
          x_{k+1}  = x_k + \frac{\Delta t}{2}(f(x_{k+1},y_{k+1})+f(x_{k},y_{k})) &  \\
          0  = g(x_{k+1},y_{k+1})& \\
        \end{cases}
        k=0,1,2,\cdots

where $\Delta t(f(x_{k+1},y_{k+1})+f(x_{k},y_{k}))$ is used to approximate the *true* integration

    .. math::
        \int_{t_{k}}^{t_{k+1}} f(x(t),y(t)) \mathrm{d}t.

Given $x_k$ and $y_k$, we use the Newton method to solve for $x_{k+1}$ and $y_{k+1}$ in the above equations. Finally, we
obtain a series of $x_0$, $x_1$, $\cdots$ and $y_0$, $y_1$, $\cdots$.

It is easily implemented in Solverz as well:

    .. plot::
       :format: doctest
       :include-source: True

       >>> from Solverz.eqn import Ode, Eqn
       >>> from Solverz.equations import DAE
       >>> from Solverz.var import TimeVar
       >>> from Solverz.variables import TimeVars
       >>> from Solverz.solvers.daesolver import implicit_trapezoid
       >>> import matplotlib.pyplot as plt
       >>> import numpy as np
       >>> # Declare your equations using strings
       >>> f = Ode(name='f', eqn='-x**3+0.5*y**2', diff_var='x')
       >>> g = Eqn(name='g', eqn='x**2+y**2-2')
       >>> dae = DAE([f, g])
       >>> # Declare the time-serise variables and give the initial values.
       >>> x = TimeVar('x')
       >>> x.v0 = [1]
       >>> y = TimeVar('y')
       >>> y.v0 = [1]
       >>> # Solve the equation with Solverz' built-in trapezoidal Solver and plot
       >>> xy = implicit_trapezoid(dae, TimeVars([x, y], length=201), 0.1, 20)
       >>> # plot
       >>> plt.plot(np.arange(0, 20.1, 0.1), xy.T)
       >>> labels=['x','y']
       >>> plt.legend(labels)
       >>> plt.xlabel('t/s', fontsize=15)
       >>> plt.show()

Let's take a look at the inside of `implicit_trapezoid()` function

    .. literalinclude:: ../../../Solverz/solvers/daesolver.py
        :language: python
        :pyobject: implicit_trapezoid

In Solverz, one can easily define a numerical integration scheme and use it to discrete the differential algebraic equations
with the `discretize()` function. And we can use `nr_method()' to iteratively solve the derived equations just the same as
the above example.

We can conclude that Solverz behaves just as what we did in mathematics, omitting the unimportant implementation details.
This kind of elegance is what we desired and stems from the hierarchy dependencies between partial differential equations (PDEs),
ordinary differential equations (ODEs) and algebraic equations (AEs), as shown in the following figure.

    .. image:: ../pics/Hierarchy_of_equations.png
       :height: 500

The core philosophy of Solverz is to abstract the mathematical models of simulations as these four kinds of equation objects
and develop easily-implemented symbolic-numerical interfaces for methods extensions.

For more complex usage of Solverz (e.g. event setting, trigger parameter and mixed matrix-vector models),
please refer to the :ref:`Solverz' cookbook <cookbook>`

Literature
==========

.. [Haierer1996] Ernst Hairer and Gerhard Wanner, Solving Ordinary Differential Equations II, 1996, `<https://link.springer.com/book/10.1007/978-3-642-05221-7>`_
